---
title: Library Reference
category: Reference
---
# Library Reference
This is how the documentation would appear in a library file, something familiar like.... Ramda.js, this example will use ramda like functions, but with added bonus example of being chained.

Almost all values act as a map or tap function in a chain, but any function can also be used as a curried standalone function - which will just take a stream of 1 value. These can be used either inside of the stream or not.

Everything is safe, so if a value returns undefined for any function, then the stream will stop execution, but the stream will not end. Catch will not end the stream, but will be called when undefined or null is returned.

The goal of this library is to create safe programming streams that do not require error checking or safe programming- do not require unwrapping, and can work with streams as well as simple arrays. A small example program can be found below:

```
Stream.$$('h1,h2') // get all h1 and h2 elements from the page
// optionally you could use const xx = Stream() as a placeholder for everything below.
    .map(Stream.click) // attaches a click listener to the above elements, creating a new stream.
    .tap(internals.doSomething) // taps the stream
    .map(internals.doSomethingElse) // maps the stream to a value
    .add(4) // adds 4 to the new value
    .both(R.gt(0), R.lt(5)) // continues the stream if the value is between 0-5
    .tap() // use that value somehow
        .map(doMore) // do something
        .map(doEvenMore) // do even more
        .return() // return to the original value
    .map()
        .sub(3)
        .pow(2)
        .negate()
        .return() // return the transformed value to the original stream
    .ap(console.log, 'The new Value: ') // prints out the new value of the stream
    .if(R.gt(2))
        .map(doSomething)
    .elsif(R.lt(5))
        .map(doSomething)
        .tap(doSomething)
    .else()
        .map(doSomething)
        .map(doSomething)
    .endif()
    .map(continue) // continue with the stream after the if break.
    .tap(continue)
    .end(); // end the stream and allow execution. (drain or observe equivelent).
```

## $
Generates a stream from document.querySelector('');

## $$
Generates a stream from document.querySelectorAll('');

## $x
Generates a stream from the XPath of a variable

## add
Adds two values together, also see [subtract](#subtract).



```
Stream([1,2,3,4])
    .add(2) // will take each number and add 2
    // stream is now [3,4,5,6]
    // Stream continues
```

## adjust
Applies a function to an array when either the index is equal to the number passed in, or the function passed in returns true

```
Stream([1,2,3,4])
    .adjust(R.add(10), 1) // stream is now [1,12,3,4]

Stream([1,2,3,4])
    .adjust(R.add(10), (x) => x == 3) // Stream is now [1,2,13,4]
```


## All
Continues a stream only if all of the values of the stream return true for a given function (this will only pass once the end of a stream is reached - not particularly useful for event streams), but useful for any finite length stream. See also [any](#any), [some](#some), and [none](#none).
```
Stream([1,2,3,4])
    .all(x => x > 0)
    . // this line is reached.

Stream([1,2,3,4])
    .all(x => x > 1)
    . // this line is not reached.
```

## allPass
Takes an array of functions, and will only continue if all of the values pass through.

```
Stream([1,2,3,4])
    .allPass([x => x > 1, x => x > 2])
    // this will not execute

Stream([1,2,3,4])
    .allPass([x => x > -1, x => x > -2])
    // this will execute

```


## always
Always returns the same value. This transforms the current value of the stream to this value.

```
Stream([1,2,3,4])
    .always(4) // Stream is now [4,4,4,4]

```

## and
Returns true if both the arguements passed in are evaluated to true.

```
Stream([1,2,3,4])
    .and( x => x >  1, x => < 4) // this will strip the stream down
    // the stream which reaches here is [2,3]
```

## any
Returns true if any of the elements succesfully pass. This will block a stream until a value passes - and then sends all of the values through (before and after the one which succeeds).

```
Stream([1,2,3,4])
    .any(x => x > 2) // will block from 1-3, and then pass all values through.
```

## anyPass
Same as allPass, except only 1 of hte functions needs to succeed in order to continue the value through the stream.

## ap
Applies the list of functions supplied to the stream, transforming the stream into a new stream.

## append
Adds a value to the end of the object being passed through the stream.

```
Stream([[1],[2],[3],[4]])
    .append(3);
    // Stream is now [[1,3], [2,3], [3,3], [4,3]]
```

## apply
Applies the arguments to the given list of values, this is useful for passing in non-library functions to the service.

```
Stream([1,2,3,4])
    .apply(console.log, 'Stream Value: ');
    //outputs:
        // Stream Value: 1
        // Stream Value: 2
        // Stream Value: 3
        // Stream Value: 4
```

## applySpec
Returns an object of the same structure passed in, but for function in the structure, the stream value will be passed instead of the original.

Stream([1,2,3,4])
    .applySpec({
        metric: milesToKm
        imperial: {
            feet: R.apply(Math.round, 0, milesToFeet)
            inches: R.apply(Math.stripInt, milesToInches)
        }
    }); // will return the object with metric and imperial measurements.

## both
See [and](#and)

##

## elif
If a stream is determined not to continue, then this can catch the non-continuation and continue it, (if this value passes).

## else
Same as `.elif`, but continues regardless. This function takes no parameters

## endif
This marks the end of an if statement in the stream, and will continue the statement. This function takes no parameters






















